


from abc import abstractmethod
from concurrent.futures import ALL_COMPLETED, ThreadPoolExecutor, wait
from typing import Generic, List, Type, TypeVar

from pydantic import Field
from rm_gallery.core.base_module import BaseModule
from rm_gallery.core.data.base import BaseDataSet
from rm_gallery.core.data.schema import DataOutput, DataSample, ChatMessage, Step
from rm_gallery.core.model.base import BaseLLM
from rm_gallery.core.rm.template import BaseTemplate


class BaseRewardModule(BaseModule):
    """
    This class is used to define a basic reward module, inheriting from BaseModule.
    
    Attributes:
        name (str): The name of the reward module. Use the default value provided by Field.
    """
    name: str = Field(default=..., description="The name of the reward module")

    @abstractmethod
    def _run(self, **kwargs):
        """
        Main processing function, intended to be implemented by subclasses.
        This method accepts arbitrary keyword arguments and its specific behavior is determined by the subclass implementation.
        
        Parameters:
        - **kwargs: Arbitrary keyword arguments, the specific parameters and their meanings are defined when the subclass implements the method.
        
        Returns:
        Since this is an abstract method, the specific return type and meaning are determined when the subclass implements the method.
        """
        ...

    @abstractmethod
    def run(self, sample: DataSample, thread_pool: ThreadPoolExecutor | None = None):
        """
        This abstract method is designed to handle the execution of a single data sample using the provided thread pool.
        Subclasses must implement this method to define the specific behavior of the task execution.
        
        Parameters:
        - sample: DataSample type, representing the data sample to be processed.
        - thread_pool: ThreadPoolExecutor type, representing the thread pool used for task execution.
        
        Returns:
        None. The specific behavior and return value are defined in the subclass implementation.
        """
        ...

    def run_batch(self, samples: BaseDataSet, thread_pool: ThreadPoolExecutor | None = None):
        """
        Execute a batch of samples using multi-threading.
    
        This method iterates over each sample in the dataset and submits it to the thread pool for execution.
        By leveraging multi-threading, this method can efficiently process multiple samples concurrently.
    
        Parameters:
        - samples: BaseDataSet
            The dataset containing multiple samples to be processed.
        - thread_pool: ThreadPoolExecutor
            The thread pool responsible for executing the samples. It manages the creation and scheduling of threads.
        """
        futures = []
        for sample in samples:
            # Submit the current sample to the thread pool for execution
            if thread_pool:
                future = thread_pool.submit(self.run, sample=sample, thread_pool=thread_pool)
                futures.append(future)
            else:
                self.run(sample=sample, thread_pool=thread_pool)

        if futures:
            completed, _ = wait(futures, return_when=ALL_COMPLETED)


class StepModule(BaseRewardModule):
    """
    The StepModule class, derived from BaseModule, is designed to calculate rewards for each step.
    It employs multi-threading to concurrently process each step's reward calculation for efficiency.
    """

    @abstractmethod
    def _run(self, input: List[ChatMessage], output: Step, step: Step):
        """
        Abstract method _run, intended to be implemented by subclasses for processing each step's reward calculation.
        
        Parameters:
        - input: A list of ChatMessage objects, representing the input messages for the chatbot.
        - output: A Step object, representing the output generated by the chatbot.
        - step: A Step object, representing the current step being processed.
        
        There is no return value for this method.
        """
        ...

    def run(self, sample: DataSample, thread_pool: ThreadPoolExecutor | None = None):
        """
        Method run processes the reward calculation for each step of the sample's output using multi-threading.
        
        Parameters:
        - sample: A DataSample object, containing the input and output data for reward calculation.
        - thread_pool: A ThreadPoolExecutor object, used for executing tasks in parallel.
        
        There is no return value for this method.
        """
        # Iterate through each output in the sample, ensuring that each output's steps are processed.
        futures = []
        for output in sample.output:
            # Assert that the steps of each output are of list type, ensuring data integrity.
            assert isinstance(output.steps, list)
            # Iterate through each step in the output, submitting tasks for parallel execution using the thread pool.
            for step in output.steps:
                if thread_pool:
                    future = thread_pool.submit(self._run, input=sample.input, output=output, step=step)
                    futures.append(future)
                else:
                    self._run(input=sample.input, output=output.answer, step=step)
            
        if futures:
            completed, _ = wait(futures, return_when=ALL_COMPLETED)


class PointModule(BaseRewardModule):
    @abstractmethod
    def _run(self, input: List[ChatMessage], output: DataOutput):
        """
        This method is responsible for processing a list of chat messages and updating the step output based on the processing results.
        It is an internal method, indicated by the leading underscore, suggesting it should not be called directly from outside the class.
    
        Parameters:
        - input (List[ChatMessage]): A list of chat messages to be processed. Each chat message is an instance of the ChatMessage class.
        - output (Step): The step object to which the processing results will be written. This allows the step's state to be updated with the chat processing outcomes.
    
        Returns:
        - None: This method does not return any value. Its primary function is to mutate the 'output' parameter based on the chat message processing.
        """
        ...

    def run(self, sample: DataSample, thread_pool: ThreadPoolExecutor | None = None):
        """
        Starts processing a data sample by submitting tasks to a thread pool.

        For each output in the data sample, a task is submitted to the thread pool for processing.
        This method does not wait for the tasks to complete.

        Parameters:
        - sample: DataSample - The data sample to be processed, containing input and a list of outputs.
        - thread_pool: ThreadPoolExecutor - The thread pool executor used to execute the tasks.
        """
        futures = []
        # Iterate through each output in the data sample
        for output in sample.output:
            # Submit a task to the thread pool for asynchronous execution
            # The _run method is called with the current input and one of the outputs as arguments
            if thread_pool:
                future = thread_pool.submit(self._run, input=sample.input, output=output)
                futures.append(future)
            else:
                self._run(input=sample.input, output=output)
        
        if futures:
            completed, _ = wait(futures, return_when=ALL_COMPLETED)


class ListModule(BaseRewardModule):
    """
    This class is a subclass of BaseModule, designed to process data samples and compute rewards.
    It is an abstract class that requires subclasses to implement the _run method to specify the specific reward calculation logic.
    
    Attributes:
    - Inherits from BaseModule, indicating it operates within a framework or system for reward calculations.
    """

    @abstractmethod
    def _run(self, sample: DataSample):
        """
        Abstract method _run, intended to be overridden by subclasses.
        This method's purpose is to process a given data sample to compute a reward.
        
        Parameters:
        - sample (DataSample): The data sample to be processed. This is the input for reward calculation.
        
        Returns:
        - None: The specific behavior and return value should be defined in the subclass implementation.
        """
        ...

    def run(self, sample: DataSample, thread_pool: ThreadPoolExecutor | None = None):
        """
        Executes the _run method in a multi-threaded environment.
        This method is intended to be called by external code, which provides a data sample and a thread pool executor.
        
        Parameters:
        - sample (DataSample): The data sample to be processed.
        - thread_pool (ThreadPoolExecutor): The thread pool executor used for concurrent execution.
        
        Returns:
        - None: The reward calculation result is not returned directly but may be stored as an attribute of the instance or output in another form.
        """
        self._run(sample=sample)


T = TypeVar("T", StepModule, PointModule, ListModule)


class LLMModule(BaseRewardModule):
    """
    A generic class for LLM-based reward modules, providing a framework for interaction with LLMs and handling rewards.
    
    Attributes:
    - llm: BaseLLM = Field(default=..., description="llm client"): The LLM client used for interaction with the language model.
    - template: Type[BaseTemplate] = Field(default=BaseTemplate, description="prompt template"): The prompt template used for generating queries to the LLM.
    """
    
    llm: BaseLLM = Field(default=..., description="llm client")
    # The description of the evaluation task is temporarily commented out, as it may not be necessary or may be handled elsewhere.
    # desc: str | None = Field(default=None, description="evaluation task description")
    template: Type[BaseTemplate] = Field(default=BaseTemplate, description="prompt template")

    def _before_call(self, **kwargs) -> dict:
        """
        Abstract method to be implemented by subclasses for preparing parameters before making a call to the LLM.
        
        Parameters:
        - **kwargs: Arbitrary keyword arguments that may be needed for preparing the call.
        
        Returns:
        - dict: A dictionary containing the prepared parameters for the LLM call.
        """
        return {}

    def _call(self, **kwargs) -> BaseTemplate:
        """
        Abstract method to be implemented by subclasses for making a call to the LLM using the provided parameters.
        
        Parameters:
        - **kwargs: Arbitrary keyword arguments that are passed to the LLM for generating a response.
        
        Returns:
        - BaseTemplate: The parsed response from the LLM, formatted according to the specified template.
        """
        return self.template.call(llm=self.llm, **kwargs)

    def _after_call(self, response: BaseTemplate, **kwargs) -> dict:
        """
        Abstract method to be implemented by subclasses for processing the response from the LLM and setting the reward.
        
        Parameters:
        - response: BaseTemplate - The parsed response from the LLM.
        - **kwargs: Arbitrary keyword arguments that may be needed for processing the response or setting the reward.
        
        Returns:
        - dict: A dictionary containing the result of the post-call processing, including the reward information.
        """
        pass

    def _run(self, **kwargs):
        """
        Method to execute the full cycle of preparing the call, making the call to the LLM, and processing the response.
        
        Parameters:
        - **kwargs: Arbitrary keyword arguments that are passed through the entire cycle of the LLM interaction.
        
        This method orchestrates the sequence of interactions with the LLM by first preparing the call parameters,
        then making the call to the LLM, and finally processing the response to set the reward.
        """
        # Prepare parameters before making the call to the LLM.
        params = self._before_call(**kwargs)

        # Make the call to the LLM using the prepared parameters.
        response = self._call(**params)

        # Process the response from the LLM and set the reward.
        self._after_call(response=response, **kwargs)
