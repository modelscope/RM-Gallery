from typing import Any, Dict, List

from rm_gallery.core.train.dataset import BaseTrainDataset
from rm_gallery.examples.train.pointwise.helpfulness_template import (
    HelperfulnessTrainTemplate,
)
from rm_gallery.gallery.rm.alignment.helpfulness import HelpfulnessPointWiseReward


class DictToAttrAdapter:
    """Adapter to allow dictionary access using attribute syntax"""

    def __init__(self, data_dict):
        self._data = data_dict

    def __getattr__(self, name):
        if name in self._data:
            value = self._data[name]
            # If the value is a list of dicts, wrap each dict as well
            if isinstance(value, list):
                return [
                    DictToAttrAdapter(item) if isinstance(item, dict) else item
                    for item in value
                ]
            elif isinstance(value, dict):
                return DictToAttrAdapter(value)
            return value
        raise AttributeError(
            f"'{type(self).__name__}' object has no attribute '{name}'"
        )

    def __getitem__(self, key):
        return self._data[key]

    def __contains__(self, key):
        return key in self._data


class HelpSteer2TrainDataset(BaseTrainDataset):
    """Specialized dataset for principle-based pointwise evaluation tasks"""

    def __init__(self, *args, **kwargs):
        # Initialize the reward module BEFORE calling parent init
        # This ensures it's available during dataset loading and filtering
        self.helpfulness_reward = HelpfulnessPointWiseReward(
            name="helpfulness_train",
            template=HelperfulnessTrainTemplate,
            examples=self._get_examples(),
            llm=None,  # Dummy LLM for format mode
            to_format=True,  # Enable format mode to generate prompts without LLM calls
        )

        # Now call parent initialization
        super().__init__(*args, **kwargs)

    def _get_examples(self) -> List[str]:
        """Get training examples for the helpfulness evaluation as a list"""
        return [
            """Example 1:
Query: Summarize the novel "The Green Mile" in 200 words.
Answer: "The Green Mile" is a novel by Stephen King, published in 1996. It is set in the 1930s and follows the story of Paul Edgecombe, a corrections officer at a prison in Louisiana. The novel is divided into two parts, with the first part focusing on Paul's life as a corrections officer and the second part focusing on the arrival of a new prisoner, John Coffey.

John Coffey is a gentle giant who is on death row for the rape and murder of two young girls. Despite his size and strength, John is a kind and gentle person who has the ability to heal people with his touch. As Paul and the other corrections officers get to know John, they begin to question his guilt and the morality of the death penalty.

Throughout the novel, John heals several people, including a fellow prisoner who is dying of cancer and the mother of one of the victims of the crime for which he was convicted. Despite these acts of kindness, John is ultimately executed for his crime.

The novel explores themes of justice, morality, and the human condition. It also provides a poignant examination of the impact of trauma and the ways in which people cope with it. "The Green Mile" is a moving and thought-provoking story that has been adapted into a film and a television series.
helpfulness score: 3""",
            """Example 2:
Query: Write a poem about identifying biases in toxic language generated by AI
Answer: Here's a poem exploring the idea of identifying biases in toxic language generated by AI:

In the realm of artificial intelligence,
Where algorithms run amuk and bias can hide,
A dangerous game is played with words and phrases,
Generated by machines with no human ties.

The language they produce can be toxic,
Full of prejudice and hate,
A reflection of the data they're fed,
And the biases that are baked in their fate.

It's up to us to identify these biases,
To call them out and make them right,
To challenge the algorithms and their creators,
And work towards a world that's free from hate and blight.

We must be vigilant in our pursuit of truth,
And hold the machines accountable for their speech,
For if we don't, the consequences will be dire,
And the future will be filled with hate and despear.

So let us not be afraid to speak out loud,
To call out the biases and the lies,
And work towards a world that's fair and just,
Where artificial intelligence serves humanity with its just dues.

For only through a conscious and critical eye,
Can we hope to create a world that's free from bias and prejudence,
And build a future that's bright and full of hope,
Where artificial intelligence is a force for good and not a source of depravity.
helpfulness score: 4""",
        ]

    def _apply_chat_template(self, messages: List[Dict[str, str]]) -> str:
        """Apply chat template with thinking enabled for principle evaluation"""
        return self.tokenizer.apply_chat_template(
            messages, add_generation_prompt=True, tokenize=False, enable_thinking=True
        )

    def _build_messages(self, example: Dict[str, Any]) -> List[Dict[str, str]]:
        """Build formatted messages directly from DataSample using reward module"""
        # Wrap the dictionary to provide attribute access
        adapted_sample = DictToAttrAdapter(example)

        # Use the reward module's evaluation framework to generate the formatted prompt
        result = self.helpfulness_reward._evaluate(sample=adapted_sample, context="")
        formatted_prompt = result.extra_data.get("prompt", "")

        return [{"role": "user", "content": formatted_prompt}]

    def _format_messages(self, messages: List[Dict[str, str]]) -> List[Dict[str, str]]:
        """Pass through - formatting is already done in _build_messages"""
        return messages

    def _extract_ground_truth(self, row_dict: Dict[str, Any]) -> str:
        """Extract ground truth for principle evaluation"""
        try:
            output_data = row_dict.get("output", [])
            if output_data:
                answer_data = output_data[0].get("answer", {})
                if isinstance(answer_data, dict):
                    label_data = answer_data.get("label", {})
                    if isinstance(label_data, dict):
                        return str(label_data.get("helpfulness", "")) or str(label_data)

            # Fallback options
            return str(row_dict.get("ground_truth", "")) or str(
                row_dict.get("answer", "")
            )
        except:
            return ""

    def _get_data_source(self, row_dict: Dict[str, Any]) -> str:
        """Get data source for principle evaluation"""
        return row_dict.get("data_source", "helpsteer2")
